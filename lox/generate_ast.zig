const std = @import("std");
const mem = std.mem;
const split = mem.split;
const trim = mem.trim;
const ArrayList = std.ArrayList;
const stdout = std.io.getStdOut().writer();

// Usage: zig run generate_ast.zig > expr.zig

fn defineType(className: []const u8, fields: []const u8) !void {
    try stdout.print("pub const {s} = struct {c}\n", .{className, '{'});

    // fields
    var f1 = split(fields, ", ");
    while (f1.next()) |field| {
        try stdout.print("    {s},\n", .{field});
    }

    // initializer
    try stdout.print("\n", .{});
    try stdout.print("    pub fn init(", .{});
    var f2 = split(fields, ", ");
    if (f2.next()) |field| {
        try stdout.print("{s}", .{field});
    }
    while (f2.next()) |field| {
        try stdout.print(", {s}", .{field});
    }
    try stdout.print(") {s} {c}\n", .{className, '{'});

    // initializer struct
    try stdout.print("        return .{c}", .{'{'});
    var f3 = split(fields, ", ");
    if (f3.next()) |field| {
        var p = split(field, ": ");
        const name = trim(u8, p.next().?, "\n");
        try stdout.print(" .{s} = {s}", .{name, name});
    }
    while (f3.next()) |field| {
        var p = split(field, ": ");
        const name = trim(u8, p.next().?, "\n");
        try stdout.print(", .{s} = {s} ", .{name, name});
    }
    try stdout.print("{c};\n", .{'}'});

    try stdout.print("    {c}\n", .{'}'});
    try stdout.print("{c};\n", .{'}'});
    try stdout.print("\n", .{});
}

fn defineAst(importName: []const u8, baseName: []const u8, types: ArrayList([]const u8)) !void {
    try stdout.print("// **This file was generated by generate_ast.zig**\n\n", .{});
    try stdout.print("const std = @import(\"std\");\n", .{});
    try stdout.print("const ArrayList = std.ArrayList;\n", .{});
    try stdout.print("const Token = @import(\"{s}\").Token;\n", .{importName});
    try stdout.print("const Value = @import(\"{s}\").Value;\n", .{importName});
    try stdout.print("\n", .{});

    for (types.items) |typ| {
        var p = split(typ, "|");
        const className = trim(u8, p.next().?, " ");
        const fields = trim(u8, p.next().?, " ");
        try defineType(className, fields);
    }
}


// pub const Visitor = struct {
//     visitBinaryExpr: fn (self: *Visitor, expr: Binary) ![]u8,
//     pub fn visitBinaryExpr(expr: Binary) []u8 {
//     }
// };
// fn defineVisitor(types: ArrayList([]const u8)) !void {
//     try stdout.print("pub const Visitor = struct {c}\n", .{'{'});

//     for (types.items) |typ| {

//     }
// }

pub fn main() !void {
    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};
    const gpa = &general_purpose_allocator.allocator;

    var types = ArrayList([]const u8).init(gpa);
    try types.append("Binary   | left: Expr, operator: Token, right: Expr");
    try types.append("Grouping | expression: Expr");
    try types.append("Literal  | value: Value");
    try types.append("Unary    | operator: Token, right: Expr");

    try defineAst("main.zig", "Expr", types);
}
